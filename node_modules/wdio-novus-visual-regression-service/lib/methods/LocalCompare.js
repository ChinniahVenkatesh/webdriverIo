"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _nodeResembleJs = _interopRequireDefault(require("node-resemble-js"));

var _BaseCompare2 = _interopRequireDefault(require("./BaseCompare"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _lodash = _interopRequireDefault(require("lodash"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var log = (0, _logger["default"])('wdio-novus-visual-regression-service:LocalCompare');

var LocalCompare = /*#__PURE__*/function (_BaseCompare) {
  (0, _inherits2["default"])(LocalCompare, _BaseCompare);

  var _super = _createSuper(LocalCompare);

  function LocalCompare() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, LocalCompare);
    _this = _super.call(this);
    _this.getScreenshotFile = options.screenshotName;
    _this.getReferencefile = options.referenceName;
    _this.getDiffFile = options.diffName;
    _this.misMatchTolerance = _lodash["default"].get(options, 'misMatchTolerance', 0.01);
    _this.ignoreComparison = _lodash["default"].get(options, 'ignoreComparison', 'nothing');
    return _this;
  }

  (0, _createClass2["default"])(LocalCompare, [{
    key: "processScreenshot",
    value: function () {
      var _processScreenshot = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(context, base64Screenshot) {
        var screenshotPath, referencePath, referenceExists, captured, ignoreComparison, compareData, isSameDimensions, misMatchPercentage, misMatchTolerance, diffPath, png;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                screenshotPath = this.getScreenshotFile(context);
                referencePath = this.getReferencefile(context);
                _context.next = 4;
                return _fsExtra["default"].outputFile(screenshotPath, base64Screenshot, 'base64');

              case 4:
                _context.next = 6;
                return _fsExtra["default"].exists(referencePath);

              case 6:
                referenceExists = _context.sent;

                if (!referenceExists) {
                  _context.next = 32;
                  break;
                }

                log.info('reference exists, compare it with the taken now');
                captured = new Buffer.from(base64Screenshot, 'base64');
                ignoreComparison = _lodash["default"].get(context, 'options.ignoreComparison', this.ignoreComparison);
                _context.next = 13;
                return this.compareImages(referencePath, captured, ignoreComparison);

              case 13:
                compareData = _context.sent;
                isSameDimensions = compareData.isSameDimensions;
                misMatchPercentage = Number(compareData.misMatchPercentage);
                misMatchTolerance = _lodash["default"].get(context, 'options.misMatchTolerance', this.misMatchTolerance);
                diffPath = this.getDiffFile(context);

                if (!(misMatchPercentage > misMatchTolerance)) {
                  _context.next = 26;
                  break;
                }

                log.info("Image is different! ".concat(misMatchPercentage, "%"));
                png = compareData.getDiffImage().pack();
                _context.next = 23;
                return this.writeDiff(png, diffPath);

              case 23:
                return _context.abrupt("return", this.createResultReport(misMatchPercentage, false, isSameDimensions));

              case 26:
                log.info("Image is within tolerance or the same");
                _context.next = 29;
                return _fsExtra["default"].remove(diffPath);

              case 29:
                return _context.abrupt("return", this.createResultReport(misMatchPercentage, true, isSameDimensions));

              case 30:
                _context.next = 36;
                break;

              case 32:
                log.info('first run - create reference file');
                _context.next = 35;
                return _fsExtra["default"].outputFile(referencePath, base64Screenshot, 'base64');

              case 35:
                return _context.abrupt("return", this.createResultReport(0, true, true));

              case 36:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function processScreenshot(_x, _x2) {
        return _processScreenshot.apply(this, arguments);
      }

      return processScreenshot;
    }()
    /**
     * Compares two images with resemble
     * @param  {Buffer|string} reference path to reference file or buffer
     * @param  {Buffer|string} screenshot path to file or buffer to compare with reference
     * @return {{misMatchPercentage: Number, isSameDimensions:Boolean, getImageDataUrl: function}}
     */

  }, {
    key: "compareImages",
    value: function () {
      var _compareImages = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(reference, screenshot) {
        var ignore,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                ignore = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : '';
                _context2.next = 3;
                return new Promise(function (resolve) {
                  var image = (0, _nodeResembleJs["default"])(reference).compareTo(screenshot);

                  switch (ignore) {
                    case 'colors':
                      image.ignoreColors();
                      break;

                    case 'antialiasing':
                      image.ignoreAntialiasing();
                      break;
                  }

                  image.onComplete(function (data) {
                    resolve(data);
                  });
                });

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function compareImages(_x3, _x4) {
        return _compareImages.apply(this, arguments);
      }

      return compareImages;
    }()
    /**
     * Writes provided diff by resemble as png
     * @param  {Stream} png node-png file Stream.
     * @return {Promise}
     */

  }, {
    key: "writeDiff",
    value: function () {
      var _writeDiff = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(png, filepath) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return new Promise(function (resolve, reject) {
                  var chunks = [];
                  png.on('data', function (chunk) {
                    chunks.push(chunk);
                  });
                  png.on('end', function () {
                    var buffer = Buffer.concat(chunks);
                    Promise.resolve().then(function () {
                      return _fsExtra["default"].outputFile(filepath, buffer.toString('base64'), 'base64');
                    }).then(function () {
                      return resolve();
                    })["catch"](reject);
                  });
                  png.on('error', function (err) {
                    return reject(err);
                  });
                });

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function writeDiff(_x5, _x6) {
        return _writeDiff.apply(this, arguments);
      }

      return writeDiff;
    }()
  }]);
  return LocalCompare;
}(_BaseCompare2["default"]);

exports["default"] = LocalCompare;